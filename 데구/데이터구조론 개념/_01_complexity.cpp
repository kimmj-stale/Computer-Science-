/**
 * 01. Algorithm performance analysis
 * 시간 복잡도에 따른 알고리즘의 성능을 평가한다.
 * 공간 복잡도에 따른 알고리즘의 용량 , 메모리 차지에 의한 알고리즘의 성능을 평가한다.
*/

/*
시간 복잡도 (time complexity) : 알고리즘 수행의 시간이 얼마나 빠른가?
공간 복잡도 (space complecity) : 알고리즘 수행에 얼마나 메모리를 적게 쓰는가?
*/

/* ex - 순차 탐색 알고리즘
int LSearch(int ar[], int len, int target)
    {
        int i;
        for(i=0; i<len; i++) {
            if(ar[i] == target)
            return i; // 찾은 대상의 인덱스 값 반환
        }
        return -1;
    }
*/

/**
 * 이진 탐색 알고리즘
 * array를 반씩 쪼개서 탐색 , 특정 요소가 발견될 때 까지 탐색
 * 모든 요소들을 탐색하는 방법 보다 더 빠르고 효과적인 방식
 * merge sort(병합 정렬)이 대표적인 예시
*/

/**
 * 이진 탐색 알고리즘의 시간 복잡도
 * 이진 탐색 알고리즘의 시간 복잡도는 worst case의 경우 T = log2n + 1
*/

/**
 * 빅O 표기법
 * 빅 오 표기법을 이용하여 시간 복잡도를 표현
 * !! 두 개의 함수 𝑓(𝑛)과 𝑔(𝑛)이 주어졌을 때, 모든 𝑛 ≥ 𝑛0에 대하여 𝑓(𝑛) ≤ 𝑐𝑔(𝑛)을 만족하는 두 개의 상수 𝑐와 𝑛0가 존재하면, 𝑓 𝑛 의 Big-Oh는 𝑂(𝑔 𝑛 ) !!
 * 최고 차항의 차수보다 작은 항들을 모두 제거하여 표기 (최고차항이 매우 커질경우 나머지 항들의 증가량은 미비해진다.)
 * 만약 시간복잡도 수식이 T(n) = n**2 + 2 * n + 1인 경우, 빅 오 표기법은 O(n**2)로 나타낼 수 있다.
*/

/* ex
T(n) = n ** 2 + 2 * n + 9      ->      O(n ** 2)
T(n) = 5 * n ** 3 + 3 * n ** 2 + 4 * n + 1      ->        O(n ** 3)
*/

/**
 * 빅 오 알고리즘의 효율성
 * O(1) < ..... < O(log n) < O(n) < O(nlog n) < O(n ** 2) < O(n ** 3) < ..... < O(2 ** n) < ...
*/
