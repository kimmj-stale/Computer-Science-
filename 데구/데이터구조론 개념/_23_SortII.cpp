/**
 * Insert Sort(삽입 정렬)
 * 정렬되어있는 부분집합에 정렬할 새로운 원소의 위치를 찾아 삽입하는 방법
*/

/*
삽입 정렬 연산 과정
정렬되지 않은 자료에서 첫 번째 원소는 정렬된 부분집합 S에 , 나머지는 정렬되지 않응 부분집합 U에 속한다 할 때
1, U에 속한 원소들이 순서대로 S의 원소들과 크기를 비교하면서 위치한다.
2, 해당 원소가 위치를 찾으면 S의 적합한 위치에 삽입된다.
3, 해당 과정들을 U에 원소가 없을 때까지 반복한다.
*/

/*  삽입 정렬 메모리 & 시간 복잡도
메모리 사용공간
- n개의 원소에 대하여 n개의 메모리 사용

연산 시간
최선의 경우
- 원소들이 이미 정렬되어있어서 비교횟수가 최소인 경우
- 이미 정렬되어있는 경우에는 바로 앞자리 원소와 한번만 비교
- 전체 비교횟수 = n-1
-> 시간 복잡도 : O(n)

최악의 경우
- 모든 원소가 역순으로 되어있어서 비교횟수가 최대인 경우
- 전체 비교횟수 = 1+2+3+ ⋯ +(n-1) = n(n-1)/2
-> 시간 복잡도 : O(n^2)

삽입 정렬의 평균 비교횟수 = n(n-1)/4
평균 시간 복잡도 : O(n^2)
*/

/* Insertion sort 구현

void insertionSort(int a[], int size) {
	int i, j, t, temp;

	for (i = 1; i < size; i++) {
		temp = a[i];
		j = i;
		while ((j > 0) && (a[j - 1] > temp)) {
			a[j] = a[j - 1];
			j = j - 1;
		}
		a[j] = temp;
		printf("\n %d단계 : ", i);
		for (t = 0; t < size; t++) printf("%3d ", a[t]);
	}
}
*/

/**
 * Shell Sort(셸 정렬)
- 일정한 간격(interval)으로 떨어져있는 자료들끼리 부분집합을 구성
- 각 부분집합에 있는 원소들에 대해서 삽입 정렬을 수행하는 작업을 반복하면서 전체 원소들을 정렬하는 방법
- 삽입 정렬의 확장판이라고 보면 됨

 * 구현 방식
- 반복될 연산의 간격 h를 설정 , 보통 자료 갯수의 절반으로 시작
- 한 단계가 끝날 때 마다 h--, h가 1이 될 때 까지 반복 후 종료
- 간격 h마다 떨어진 원소끼리 부분집합을 형성하여 비교하는 형식

 * 수행 능력
- n개의 원소 갯수와 매개 변수 h에 대한 메모리를 소모
- 시간 복잡도가 O(n ^ 2)인 삽입 정렬에 비해 O(n ^ 1.25)로 개선된 알고리즘
- 하지만 여전히 시간 복잡도가 높아 좋지 않은 알고리즘인 것은 여전
*/

/*
void shellSort(int a[], int size) {
    int i, t, interval;
    printf("\n정렬할 원소 : ");

    for (t = 0; t<size; t++) printf("%d ", a[t]);
    printf("\n\n<<<<<<<<<< 셸 정렬 수행 >>>>>>>>>>\n");

    interval = size / 2;
    while (interval >= 1) {
        for (i = 0; i<interval; i++) intervalSort(a, i, size - 1, interval);
        printf("\n interval=%d >> ", interval);
        for (t = 0; t<size; t++) printf("%d ", a[t]);
        printf("\n");
        interval = interval / 2;
    }
}
*/